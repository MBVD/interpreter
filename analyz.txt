expressions

любой id котоырй был использован должен быть проинициализирован

f() -> проверка что f это функция
f[] -> проверка на f - массив
f. -> проверка на f что структура

проверка на применимость оператора
типа к string нельзя применять ++ -- и тд 
мы делаем без перегрузок поэтому к структуре нельзя использовать операторы вообще
при вложенных операнадах надо вычислять какой тип будет получен


int + int -> long long
short + short -> int
char + char -> int
float + float -> double -float -> -double
char + long -> long - сравнение размеров типов
float + int -> float


оператор сравнения используется для арифм типов
+- и тд к арифм типам
логич тип применим к тем которые конв в бул
битовый тип применим только к целым числам
примсв применимо толлько если конвертируется типы
a = b a должно быть lvalue
, - нет проверок 
++ -- + - - африфм и lvalue

* применяется только к указателям
& примменим к любому lvalue

cond ? true : false 
true и false должны быть конвертируемы
cond - логическй тип


struct-уры это обьекты



statements

block - когда заходим в блок пораждается безымяное пространство имен (новая область видимости)
if - условие конвертируется в бул тип
loop - условие конвертируется в бул тип
break - справедлив когда счетчик циклов > 0
continue - справедлив когда счетчик циклов > 0
return - тип конвертируется к типу к которому он конвертируется
decl - анализ как decl
expr - анализ также как expr

1)symbol символ
2)scope область видимости (ссылка на прошлую область, symbol table) - должна быть ссылка на родительскую область видимости local_find и find add_symbol и insert enter(создаемм и заходим в потомок) и leave()
3) Type 
    1) одна большая структура, enum с разными типами – много кода, однотипен
    2) много классов с наследованием, работает дольше, пишешь меньше

    struct Symbol
1)var   2)func  3)struct


TranslationUnit - должно быть во главе дерева начинается с обьявлений

TYPE 
        1)fundamental                                                               2)composite
1) void 2)nullptr 3)arithmetic(4)                                  1)func           2)record        3)enum      4)pointer       5)ref       6)array
                  1) Integral               2) floating                     1)struct 2)class 3)union                        1)lref2)rref    1)    2)
                1)bool,2)char3)integer    

pointer приводит к integral типам
enum - целый тип
ref - все для ссылаемого типа
array - конвертируется в pointer
func - конвертируется в pointer (но нам не надо)
typeid(a + b)

Понятие операции

Отделение операторного токена от самого оператора: например плюс на бинарный и унарный плюс. 

operation(действие) можно сделать структурой

на этапе семантики операция должна проверяться что она применима, без вычисления операции должны определить тип результата.




runtime ошибки



declarations

var 

func

struct